import os
import uuid
from datetime import date, datetime
from typing import Optional, List, Literal

from fastapi import FastAPI, Depends, HTTPException, Query
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel, Field, EmailStr, constr
from dotenv import load_dotenv

from sqlalchemy import create_engine, text
from sqlalchemy.engine import Engine, Connection
from sqlalchemy.orm import sessionmaker
from sqlalchemy.exc import IntegrityError

# ----------------------------------------------------------------------------
# Config & DB engine
# ----------------------------------------------------------------------------
load_dotenv()
DATABASE_URL = os.getenv("DATABASE_URL")
if not DATABASE_URL:
    raise RuntimeError("DATABASE_URL is not set. See .env.example")

engine: Engine = create_engine(
    DATABASE_URL,
    pool_pre_ping=True,
    pool_size=5,
    max_overflow=5,
    future=True,
)
SessionLocal = sessionmaker(bind=engine, autoflush=False, autocommit=False, future=True)

app = FastAPI(title="Core/ECM/AML API (Postgres)", version="1.0")
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

def get_conn():
    with engine.begin() as conn:
        yield conn

# ----------------------------------------------------------------------------
# (Optional) Safety: ensure extensions/schemas exist on startup
# ----------------------------------------------------------------------------
DDL = r"""
CREATE EXTENSION IF NOT EXISTS pgcrypto;
CREATE SCHEMA IF NOT EXISTS core;
CREATE SCHEMA IF NOT EXISTS ecm;
CREATE SCHEMA IF NOT EXISTS aml;

CREATE TABLE IF NOT EXISTS core.customer (
  cif         BIGINT GENERATED BY DEFAULT AS IDENTITY (START 1000000000 INCREMENT 1) PRIMARY KEY,
  nationalid  CHAR(14) UNIQUE,
  passportno  VARCHAR(30) UNIQUE,
  namear      VARCHAR(200) NOT NULL,
  nameen      VARCHAR(200),
  dob         DATE NOT NULL,
  gender      CHAR(1) NOT NULL CHECK (gender IN ('M','F')),
  address     VARCHAR(400),
  mobile      VARCHAR(20) NOT NULL,
  email       VARCHAR(200),
  branchcode  VARCHAR(10) NOT NULL,
  createdat   TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE TABLE IF NOT EXISTS core.account (
  accountnumber VARCHAR(20) PRIMARY KEY,
  cif           BIGINT NOT NULL REFERENCES core.customer(cif),
  accounttype   VARCHAR(30) NOT NULL,
  currency      CHAR(3) NOT NULL,
  debitblocked  BOOLEAN NOT NULL DEFAULT false,
  productcode   VARCHAR(30),
  createdat     TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE TABLE IF NOT EXISTS ecm.folder (
  folderid   UUID NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
  cif        BIGINT NOT NULL,
  requestid  VARCHAR(50) NOT NULL,
  pathhint   VARCHAR(500),
  createdat  TIMESTAMPTZ NOT NULL DEFAULT now(),
  CONSTRAINT uq_folder UNIQUE (cif, requestid)
);

CREATE TABLE IF NOT EXISTS ecm.document (
  documentid  UUID NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
  folderid    UUID NOT NULL REFERENCES ecm.folder(folderid) ON DELETE CASCADE,
  requestid   VARCHAR(50) NOT NULL,
  doctype     VARCHAR(50) NOT NULL,
  filename    VARCHAR(255) NOT NULL,
  uploadedat  TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE TABLE IF NOT EXISTS aml.screening (
  screeningid UUID NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
  nationalid  CHAR(14),
  passportno  VARCHAR(30),
  namear      VARCHAR(200),
  nameen      VARCHAR(200),
  riskscore   INT NOT NULL,
  risklevel   VARCHAR(10) NOT NULL CHECK (risklevel IN ('LOW','MEDIUM','HIGH')),
  hitscount   INT NOT NULL DEFAULT 0,
  performedat TIMESTAMPTZ NOT NULL DEFAULT now()
);
"""

@app.on_event("startup")
def apply_schema():
    with engine.begin() as conn:
        conn.execute(text(DDL))

# ----------------------------------------------------------------------------
# Pydantic I/O models
# ----------------------------------------------------------------------------
class CustomerCreate(BaseModel):
    NationalID: Optional[constr(strict=True, min_length=14, max_length=14)] = None
    PassportNo: Optional[str] = None
    NameAr: constr(strip_whitespace=True, min_length=1, max_length=200)
    NameEn: Optional[str] = None
    DOB: date
    Gender: Literal["M", "F"]                     # ⬅️ was: constr(regex=...)
    Address: Optional[str] = None
    Mobile: constr(min_length=4, max_length=20)
    Email: Optional[EmailStr] = None
    BranchCode: constr(min_length=1, max_length=10)


class CustomerUpdate(BaseModel):
    NationalID: Optional[constr(strict=True, min_length=14, max_length=14)] = None
    PassportNo: Optional[str] = None
    NameAr: Optional[str] = None
    NameEn: Optional[str] = None
    DOB: Optional[date] = None
    Gender: Optional[Literal["M", "F"]] = None    # ⬅️ was: constr(regex=...)
    Address: Optional[str] = None
    Mobile: Optional[str] = None
    Email: Optional[EmailStr] = None
    BranchCode: Optional[str] = None


class CustomerOut(CustomerCreate):
    CIF: int
    CreatedAt: datetime

class AccountCreate(BaseModel):
    AccountNumber: constr(min_length=1, max_length=20)
    CIF: int
    AccountType: constr(min_length=1, max_length=30)
    Currency: constr(min_length=3, max_length=3)
    DebitBlocked: Optional[bool] = False
    ProductCode: Optional[str] = None

class AccountUpdate(BaseModel):
    AccountType: Optional[str] = None
    Currency: Optional[constr(min_length=3, max_length=3)] = None
    DebitBlocked: Optional[bool] = None
    ProductCode: Optional[str] = None

class AccountOut(AccountCreate):
    CreatedAt: datetime

class FolderCreate(BaseModel):
    CIF: int
    RequestId: constr(min_length=1, max_length=50)
    PathHint: Optional[str] = None

class FolderUpdate(BaseModel):
    PathHint: Optional[str] = None

class FolderOut(FolderCreate):
    FolderId: uuid.UUID
    CreatedAt: datetime

class DocumentCreate(BaseModel):
    FolderId: uuid.UUID
    RequestId: constr(min_length=1, max_length=50)
    DocType: constr(min_length=1, max_length=50)
    FileName: constr(min_length=1, max_length=255)

class DocumentUpdate(BaseModel):
    DocType: Optional[str] = None
    FileName: Optional[str] = None

class DocumentOut(DocumentCreate):
    DocumentId: uuid.UUID
    UploadedAt: datetime

class ScreeningCreate(BaseModel):
    NationalID: Optional[constr(strict=True, min_length=14, max_length=14)] = None
    PassportNo: Optional[str] = None
    NameAr: Optional[str] = None
    NameEn: Optional[str] = None
    RiskScore: int
    RiskLevel: Literal["LOW", "MEDIUM", "HIGH"]   # ⬅️ was: constr(regex=...)
    HitsCount: Optional[int] = 0


class ScreeningUpdate(BaseModel):
    NationalID: Optional[constr(strict=True, min_length=14, max_length=14)] = None
    PassportNo: Optional[str] = None
    NameAr: Optional[str] = None
    NameEn: Optional[str] = None
    RiskScore: Optional[int] = None
    RiskLevel: Optional[Literal["LOW", "MEDIUM", "HIGH"]] = None  # ⬅️ was: constr(regex=...)
    HitsCount: Optional[int] = None


class ScreeningOut(ScreeningCreate):
    ScreeningId: uuid.UUID
    PerformedAt: datetime

# ----------------------------------------------------------------------------
# Helpers
# ----------------------------------------------------------------------------

def row_to_dict(row):
    return dict(row._mapping)

# ----------------------------------------------------------------------------
# CRUD — Customers
# ----------------------------------------------------------------------------
@app.post("/core/customers", response_model=CustomerOut, status_code=201)
def create_customer(payload: CustomerCreate, conn: Connection = Depends(get_conn)):
    sql = text(
        """
        INSERT INTO core.customer
        (nationalid, passportno, namear, nameen, dob, gender, address, mobile, email, branchcode)
        VALUES (:NationalID, :PassportNo, :NameAr, :NameEn, :DOB, :Gender, :Address, :Mobile, :Email, :BranchCode)
        RETURNING cif AS "CIF", nationalid AS "NationalID", passportno AS "PassportNo", namear AS "NameAr",
                  nameen AS "NameEn", dob AS "DOB", gender AS "Gender", address AS "Address", mobile AS "Mobile",
                  email AS "Email", branchcode AS "BranchCode", createdat AS "CreatedAt"
        """
    )
    try:
        row = conn.execute(sql, payload.model_dump()).fetchone()
        return row_to_dict(row)
    except IntegrityError as e:
        raise HTTPException(status_code=400, detail=str(e.orig))

@app.get("/core/customers/{cif}", response_model=CustomerOut)
def get_customer(cif: int, conn: Connection = Depends(get_conn)):
    sql = text("SELECT cif AS \"CIF\", nationalid AS \"NationalID\", passportno AS \"PassportNo\", namear AS \"NameAr\", nameen AS \"NameEn\", dob AS \"DOB\", gender AS \"Gender\", address AS \"Address\", mobile AS \"Mobile\", email AS \"Email\", branchcode AS \"BranchCode\", createdat AS \"CreatedAt\" FROM core.customer WHERE cif=:cif")
    row = conn.execute(sql, {"cif": cif}).fetchone()
    if not row:
        raise HTTPException(status_code=404, detail="Customer not found")
    return row_to_dict(row)

@app.get("/core/customers", response_model=List[CustomerOut])
def list_customers(branch: Optional[str] = Query(None), limit: int = Query(50, ge=1, le=500), conn: Connection = Depends(get_conn)):
    base = "SELECT cif AS \"CIF\", nationalid AS \"NationalID\", passportno AS \"PassportNo\", namear AS \"NameAr\", nameen AS \"NameEn\", dob AS \"DOB\", gender AS \"Gender\", address AS \"Address\", mobile AS \"Mobile\", email AS \"Email\", branchcode AS \"BranchCode\", createdat AS \"CreatedAt\" FROM core.customer"
    params = {"lim": limit}
    if branch:
        base += " WHERE branchcode = :branch"
        params["branch"] = branch
    base += " ORDER BY cif DESC LIMIT :lim"
    rows = conn.execute(text(base), params).fetchall()
    return [row_to_dict(r) for r in rows]

@app.get("/core/customers/by-national-id/{national_id}", response_model=CustomerOut)
def get_customer_by_national_id(national_id: str, conn: Connection = Depends(get_conn)):
    sql = text("""
        SELECT cif AS "CIF", nationalid AS "NationalID", passportno AS "PassportNo", namear AS "NameAr",
               nameen AS "NameEn", dob AS "DOB", gender AS "Gender", address AS "Address", mobile AS "Mobile",
               email AS "Email", branchcode AS "BranchCode", createdat AS "CreatedAt"
        FROM core.customer
        WHERE nationalid = :nid
        """)
    row = conn.execute(sql, {"nid": national_id}).fetchone()
    if not row:
        raise HTTPException(status_code=404, detail="Customer with this NationalID not found")
    return row_to_dict(row)


@app.patch("/core/customers/{cif}", response_model=CustomerOut)
def update_customer(cif: int, payload: CustomerUpdate, conn: Connection = Depends(get_conn)):
    data = {k: v for k, v in payload.model_dump(exclude_unset=True).items()}
    if not data:
        return get_customer(cif, conn)
    sets = ", ".join([f"{k.lower()} = :{k}" for k in data.keys()])
    data["cif"] = cif
    sql = text(
        f"""
        UPDATE core.customer SET {sets}
        WHERE cif = :cif
        RETURNING cif AS "CIF", nationalid AS "NationalID", passportno AS "PassportNo", namear AS "NameAr",
                  nameen AS "NameEn", dob AS "DOB", gender AS "Gender", address AS "Address", mobile AS "Mobile",
                  email AS "Email", branchcode AS "BranchCode", createdat AS "CreatedAt";
        """
    )
    try:
        row = conn.execute(sql, data).fetchone()
        if not row:
            raise HTTPException(status_code=404, detail="Customer not found")
        return row_to_dict(row)
    except IntegrityError as e:
        raise HTTPException(status_code=400, detail=str(e.orig))

@app.delete("/core/customers/{cif}", status_code=204)
def delete_customer(cif: int, conn: Connection = Depends(get_conn)):
    res = conn.execute(text("DELETE FROM core.customer WHERE cif=:cif"), {"cif": cif})
    if res.rowcount == 0:
        raise HTTPException(status_code=404, detail="Customer not found")
    return

@app.post("/core/customers/createCIF", status_code=201)
def create_cif(payload: CustomerCreate, conn: Connection = Depends(get_conn)):
    sql = text(
        """
        INSERT INTO core.customer
        (nationalid, passportno, namear, nameen, dob, gender, address, mobile, email, branchcode)
        VALUES (:NationalID, :PassportNo, :NameAr, :NameEn, :DOB, :Gender, :Address, :Mobile, :Email, :BranchCode)
        RETURNING cif AS "CIF"
        """
    )
    try:
        row = conn.execute(sql, payload.model_dump()).fetchone()
        return {"CIF": row["CIF"]}
    except IntegrityError as e:
        raise HTTPException(status_code=400, detail=str(e.orig))


# ----------------------------------------------------------------------------
# CRUD — Accounts
# ----------------------------------------------------------------------------
@app.post("/core/accounts", response_model=AccountOut, status_code=201)
def create_account(payload: AccountCreate, conn: Connection = Depends(get_conn)):
    sql = text(
        """
        INSERT INTO core.account (accountnumber, cif, accounttype, currency, debitblocked, productcode)
        VALUES (:AccountNumber, :CIF, :AccountType, :Currency, :DebitBlocked, :ProductCode)
        RETURNING accountnumber AS "AccountNumber", cif AS "CIF", accounttype AS "AccountType", currency AS "Currency",
                  debitblocked AS "DebitBlocked", productcode AS "ProductCode", createdat AS "CreatedAt"
        """
    )
    try:
        row = conn.execute(sql, payload.model_dump()).fetchone()
        return row_to_dict(row)
    except IntegrityError as e:
        raise HTTPException(status_code=400, detail=str(e.orig))

@app.post("/core/accounts/createAccount", status_code=201)
def create_account_locked(payload: AccountCreate, conn: Connection = Depends(get_conn)):
    data = payload.model_dump()
    data["DebitBlocked"] = True  # force initial block
    sql = text(
        """
        INSERT INTO core.account (accountnumber, cif, accounttype, currency, debitblocked, productcode)
        VALUES (:AccountNumber, :CIF, :AccountType, :Currency, :DebitBlocked, :ProductCode)
        RETURNING accountnumber AS "AccountNumber"
        """
    )
    try:
        row = conn.execute(sql, data).fetchone()
        return {"AccountNumber": row["AccountNumber"]}
    except IntegrityError as e:
        raise HTTPException(status_code=400, detail=str(e.orig))


@app.get("/core/accounts/{account_number}", response_model=AccountOut)
def get_account(account_number: str, conn: Connection = Depends(get_conn)):
    sql = text("SELECT accountnumber AS \"AccountNumber\", cif AS \"CIF\", accounttype AS \"AccountType\", currency AS \"Currency\", debitblocked AS \"DebitBlocked\", productcode AS \"ProductCode\", createdat AS \"CreatedAt\" FROM core.account WHERE accountnumber=:acc")
    row = conn.execute(sql, {"acc": account_number}).fetchone()
    if not row:
        raise HTTPException(status_code=404, detail="Account not found")
    return row_to_dict(row)

@app.get("/core/accounts", response_model=List[AccountOut])
def list_accounts(cif: Optional[int] = Query(None), limit: int = Query(50, ge=1, le=500), conn: Connection = Depends(get_conn)):
    base = "SELECT accountnumber AS \"AccountNumber\", cif AS \"CIF\", accounttype AS \"AccountType\", currency AS \"Currency\", debitblocked AS \"DebitBlocked\", productcode AS \"ProductCode\", createdat AS \"CreatedAt\" FROM core.account"
    params = {"lim": limit}
    if cif is not None:
        base += " WHERE cif = :cif"
        params["cif"] = cif
    base += " ORDER BY createdat DESC LIMIT :lim"
    rows = conn.execute(text(base), params).fetchall()
    return [row_to_dict(r) for r in rows]

@app.patch("/core/accounts/{account_number}", response_model=AccountOut)
def update_account(account_number: str, payload: AccountUpdate, conn: Connection = Depends(get_conn)):
    data = {k: v for k, v in payload.model_dump(exclude_unset=True).items()}
    if not data:
        return get_account(account_number, conn)
    sets = ", ".join([f"{k.lower()} = :{k}" for k in data.keys()])
    data["acc"] = account_number
    sql = text(
        f"""
        UPDATE core.account SET {sets}
        WHERE accountnumber = :acc
        RETURNING accountnumber AS "AccountNumber", cif AS "CIF", accounttype AS "AccountType", currency AS "Currency",
                  debitblocked AS "DebitBlocked", productcode AS "ProductCode", createdat AS "CreatedAt";
        """
    )
    try:
        row = conn.execute(sql, data).fetchone()
        if not row:
            raise HTTPException(status_code=404, detail="Account not found")
        return row_to_dict(row)
    except IntegrityError as e:
        raise HTTPException(status_code=400, detail=str(e.orig))

@app.delete("/core/accounts/{account_number}", status_code=204)
def delete_account(account_number: str, conn: Connection = Depends(get_conn)):
    res = conn.execute(text("DELETE FROM core.account WHERE accountnumber=:acc"), {"acc": account_number})
    if res.rowcount == 0:
        raise HTTPException(status_code=404, detail="Account not found")
    return

# ----------------------------------------------------------------------------
# CRUD — ECM Folders
# ----------------------------------------------------------------------------
@app.post("/ecm/folders", response_model=FolderOut, status_code=201)
def create_folder(payload: FolderCreate, conn: Connection = Depends(get_conn)):
    sql = text(
        """
        INSERT INTO ecm.folder (cif, requestid, pathhint)
        VALUES (:CIF, :RequestId, :PathHint)
        RETURNING folderid AS "FolderId", cif AS "CIF", requestid AS "RequestId", pathhint AS "PathHint", createdat AS "CreatedAt"
        """
    )
    try:
        row = conn.execute(sql, payload.model_dump()).fetchone()
        return row_to_dict(row)
    except IntegrityError as e:
        raise HTTPException(status_code=400, detail=str(e.orig))

@app.get("/ecm/folders/{folder_id}", response_model=FolderOut)
def get_folder(folder_id: uuid.UUID, conn: Connection = Depends(get_conn)):
    sql = text("SELECT folderid AS \"FolderId\", cif AS \"CIF\", requestid AS \"RequestId\", pathhint AS \"PathHint\", createdat AS \"CreatedAt\" FROM ecm.folder WHERE folderid=:id")
    row = conn.execute(sql, {"id": str(folder_id)}).fetchone()
    if not row:
        raise HTTPException(status_code=404, detail="Folder not found")
    return row_to_dict(row)

@app.get("/ecm/folders/by-cif/{cif}", response_model=FolderOut)
def get_folder_by_cif(cif: int, conn: Connection = Depends(get_conn)):
    sql = text("""
        SELECT folderid AS "FolderId", cif AS "CIF", requestid AS "RequestId",
               pathhint AS "PathHint", createdat AS "CreatedAt"
        FROM ecm.folder
        WHERE cif = :cif
        ORDER BY createdat DESC
        LIMIT 1
    """)
    row = conn.execute(sql, {"cif": cif}).fetchone()
    if not row:
        raise HTTPException(status_code=404, detail="No folder found for this CIF")
    return row_to_dict(row)


@app.get("/ecm/folders", response_model=List[FolderOut])
def list_folders(cif: Optional[int] = Query(None), request_id: Optional[str] = Query(None), limit: int = Query(50, ge=1, le=500), conn: Connection = Depends(get_conn)):
    base = "SELECT folderid AS \"FolderId\", cif AS \"CIF\", requestid AS \"RequestId\", pathhint AS \"PathHint\", createdat AS \"CreatedAt\" FROM ecm.folder"
    params = {"lim": limit}
    filters = []
    if cif is not None:
        filters.append("cif = :cif"); params["cif"] = cif
    if request_id:
        filters.append("requestid = :rid"); params["rid"] = request_id
    if filters:
        base += " WHERE " + " AND ".join(filters)
    base += " ORDER BY createdat DESC LIMIT :lim"
    rows = conn.execute(text(base), params).fetchall()
    return [row_to_dict(r) for r in rows]

@app.patch("/ecm/folders/{folder_id}", response_model=FolderOut)
def update_folder(folder_id: uuid.UUID, payload: FolderUpdate, conn: Connection = Depends(get_conn)):
    data = {k: v for k, v in payload.model_dump(exclude_unset=True).items()}
    if not data:
        return get_folder(folder_id, conn)
    sets = ", ".join([f"{k.lower()} = :{k}" for k in data.keys()])
    data["id"] = str(folder_id)
    sql = text(
        f"""
        UPDATE ecm.folder SET {sets}
        WHERE folderid = :id
        RETURNING folderid AS "FolderId", cif AS "CIF", requestid AS "RequestId", pathhint AS "PathHint", createdat AS "CreatedAt";
        """
    )
    row = conn.execute(sql, data).fetchone()
    if not row:
        raise HTTPException(status_code=404, detail="Folder not found")
    return row_to_dict(row)

@app.delete("/ecm/folders/{folder_id}", status_code=204)
def delete_folder(folder_id: uuid.UUID, conn: Connection = Depends(get_conn)):
    res = conn.execute(text("DELETE FROM ecm.folder WHERE folderid=:id"), {"id": str(folder_id)})
    if res.rowcount == 0:
        raise HTTPException(status_code=404, detail="Folder not found")
    return

# ----------------------------------------------------------------------------
# CRUD — ECM Documents
# ----------------------------------------------------------------------------
@app.post("/ecm/documents", response_model=DocumentOut, status_code=201)
def create_document(payload: DocumentCreate, conn: Connection = Depends(get_conn)):
    sql = text(
        """
        INSERT INTO ecm.document (folderid, requestid, doctype, filename)
        VALUES (:FolderId, :RequestId, :DocType, :FileName)
        RETURNING documentid AS "DocumentId", folderid AS "FolderId", requestid AS "RequestId", doctype AS "DocType",
                  filename AS "FileName", uploadedat AS "UploadedAt"
        """
    )
    try:
        row = conn.execute(sql, {"FolderId": str(payload.FolderId), "RequestId": payload.RequestId, "DocType": payload.DocType, "FileName": payload.FileName}).fetchone()
        return row_to_dict(row)
    except IntegrityError as e:
        raise HTTPException(status_code=400, detail=str(e.orig))

@app.get("/ecm/documents/{document_id}", response_model=DocumentOut)
def get_document(document_id: uuid.UUID, conn: Connection = Depends(get_conn)):
    sql = text("SELECT documentid AS \"DocumentId\", folderid AS \"FolderId\", requestid AS \"RequestId\", doctype AS \"DocType\", filename AS \"FileName\", uploadedat AS \"UploadedAt\" FROM ecm.document WHERE documentid=:id")
    row = conn.execute(sql, {"id": str(document_id)}).fetchone()
    if not row:
        raise HTTPException(status_code=404, detail="Document not found")
    return row_to_dict(row)

@app.get("/ecm/documents", response_model=List[DocumentOut])
def list_documents(folder_id: Optional[uuid.UUID] = Query(None), request_id: Optional[str] = Query(None), doc_type: Optional[str] = Query(None), limit: int = Query(50, ge=1, le=500), conn: Connection = Depends(get_conn)):
    base = "SELECT documentid AS \"DocumentId\", folderid AS \"FolderId\", requestid AS \"RequestId\", doctype AS \"DocType\", filename AS \"FileName\", uploadedat AS \"UploadedAt\" FROM ecm.document"
    params = {"lim": limit}
    filters = []
    if folder_id:
        filters.append("folderid = :fid"); params["fid"] = str(folder_id)
    if request_id:
        filters.append("requestid = :rid"); params["rid"] = request_id
    if doc_type:
        filters.append("doctype = :dt"); params["dt"] = doc_type
    if filters:
        base += " WHERE " + " AND ".join(filters)
    base += " ORDER BY uploadedat DESC LIMIT :lim"
    rows = conn.execute(text(base), params).fetchall()
    return [row_to_dict(r) for r in rows]

@app.get("/ecm/documents/by-folder-request", response_model=DocumentOut)
def get_doc_by_folderid_requestid(
    folder_id: uuid.UUID = Query(...),
    request_id: str = Query(...),
    conn: Connection = Depends(get_conn),
):
    sql = text("""
        SELECT documentid AS "DocumentId", folderid AS "FolderId", requestid AS "RequestId",
               doctype AS "DocType", filename AS "FileName", uploadedat AS "UploadedAt"
        FROM ecm.document
        WHERE folderid = :fid AND requestid = :rid
        ORDER BY uploadedat DESC
        LIMIT 1
    """)
    row = conn.execute(sql, {"fid": str(folder_id), "rid": request_id}).fetchone()
    if not row:
        raise HTTPException(status_code=404, detail="No document found for this FolderId and RequestId")
    return row_to_dict(row)


@app.patch("/ecm/documents/{document_id}", response_model=DocumentOut)
def update_document(document_id: uuid.UUID, payload: DocumentUpdate, conn: Connection = Depends(get_conn)):
    data = {k: v for k, v in payload.model_dump(exclude_unset=True).items()}
    if not data:
        return get_document(document_id, conn)
    sets = ", ".join([f"{k.lower()} = :{k}" for k in data.keys()])
    data["id"] = str(document_id)
    sql = text(
        f"""
        UPDATE ecm.document SET {sets}
        WHERE documentid = :id
        RETURNING documentid AS "DocumentId", folderid AS "FolderId", requestid AS "RequestId", doctype AS "DocType",
                  filename AS "FileName", uploadedat AS "UploadedAt";
        """
    )
    row = conn.execute(sql, data).fetchone()
    if not row:
        raise HTTPException(status_code=404, detail="Document not found")
    return row_to_dict(row)

@app.delete("/ecm/documents/{document_id}", status_code=204)
def delete_document(document_id: uuid.UUID, conn: Connection = Depends(get_conn)):
    res = conn.execute(text("DELETE FROM ecm.document WHERE documentid=:id"), {"id": str(document_id)})
    if res.rowcount == 0:
        raise HTTPException(status_code=404, detail="Document not found")
    return

# ----------------------------------------------------------------------------
# CRUD — AML Screenings
# ----------------------------------------------------------------------------
@app.post("/aml/screenings", response_model=ScreeningOut, status_code=201)
def create_screening(payload: ScreeningCreate, conn: Connection = Depends(get_conn)):
    sql = text(
        """
        INSERT INTO aml.screening (nationalid, passportno, namear, nameen, riskscore, risklevel, hitscount)
        VALUES (:NationalID, :PassportNo, :NameAr, :NameEn, :RiskScore, :RiskLevel, :HitsCount)
        RETURNING screeningid AS "ScreeningId", nationalid AS "NationalID", passportno AS "PassportNo", namear AS "NameAr", nameen AS "NameEn",
                  riskscore AS "RiskScore", risklevel AS "RiskLevel", hitscount AS "HitsCount", performedat AS "PerformedAt"
        """
    )
    try:
        row = conn.execute(sql, payload.model_dump()).fetchone()
        return row_to_dict(row)
    except IntegrityError as e:
        raise HTTPException(status_code=400, detail=str(e.orig))

@app.get("/aml/screenings/{screening_id}", response_model=ScreeningOut)
def get_screening(screening_id: uuid.UUID, conn: Connection = Depends(get_conn)):
    sql = text("SELECT screeningid AS \"ScreeningId\", nationalid AS \"NationalID\", passportno AS \"PassportNo\", namear AS \"NameAr\", nameen AS \"NameEn\", riskscore AS \"RiskScore\", risklevel AS \"RiskLevel\", hitscount AS \"HitsCount\", performedat AS \"PerformedAt\" FROM aml.screening WHERE screeningid=:id")
    row = conn.execute(sql, {"id": str(screening_id)}).fetchone()
    if not row:
        raise HTTPException(status_code=404, detail="Screening not found")
    return row_to_dict(row)

@app.get("/aml/screenings", response_model=List[ScreeningOut])
def list_screenings(national_id: Optional[str] = Query(None), passport_no: Optional[str] = Query(None), risk_level: Optional[str] = Query(None, pattern=r"^(LOW|MEDIUM|HIGH)$"), limit: int = Query(50, ge=1, le=500), conn: Connection = Depends(get_conn)):
    base = "SELECT screeningid AS \"ScreeningId\", nationalid AS \"NationalID\", passportno AS \"PassportNo\", namear AS \"NameAr\", nameen AS \"NameEn\", riskscore AS \"RiskScore\", risklevel AS \"RiskLevel\", hitscount AS \"HitsCount\", performedat AS \"PerformedAt\" FROM aml.screening"
    params = {"lim": limit}
    filters = []
    if national_id:
        filters.append("nationalid = :nid"); params["nid"] = national_id
    if passport_no:
        filters.append("passportno = :pp"); params["pp"] = passport_no
    if risk_level:
        filters.append("risklevel = :rl"); params["rl"] = risk_level
    if filters:
        base += " WHERE " + " AND ".join(filters)
    base += " ORDER BY performedat DESC LIMIT :lim"
    rows = conn.execute(text(base), params).fetchall()
    return [row_to_dict(r) for r in rows]

@app.get("/aml/screenings/by-national-id/{national_id}", response_model=ScreeningOut)
def get_screening_by_national_id(national_id: str, conn: Connection = Depends(get_conn)):
    sql = text("""
        SELECT screeningid AS "ScreeningId", nationalid AS "NationalID", passportno AS "PassportNo",
               namear AS "NameAr", nameen AS "NameEn", riskscore AS "RiskScore", risklevel AS "RiskLevel",
               hitscount AS "HitsCount", performedat AS "PerformedAt"
        FROM aml.screening
        WHERE nationalid = :nid
        ORDER BY performedat DESC
        LIMIT 1
    """)
    row = conn.execute(sql, {"nid": national_id}).fetchone()
    if not row:
        raise HTTPException(status_code=404, detail="No screening found for this NationalID")
    return row_to_dict(row)


@app.patch("/aml/screenings/{screening_id}", response_model=ScreeningOut)
def update_screening(screening_id: uuid.UUID, payload: ScreeningUpdate, conn: Connection = Depends(get_conn)):
    data = {k: v for k, v in payload.model_dump(exclude_unset=True).items()}
    if not data:
        return get_screening(screening_id, conn)
    sets = ", ".join([f"{k.lower()} = :{k}" for k in data.keys()])
    data["id"] = str(screening_id)
    sql = text(
        f"""
        UPDATE aml.screening SET {sets}
        WHERE screeningid = :id
        RETURNING screeningid AS "ScreeningId", nationalid AS "NationalID", passportno AS "PassportNo", namear AS "NameAr", nameen AS "NameEn",
                  riskscore AS "RiskScore", risklevel AS "RiskLevel", hitscount AS "HitsCount", performedat AS "PerformedAt";
        """
    )
    try:
        row = conn.execute(sql, data).fetchone()
        if not row:
            raise HTTPException(status_code=404, detail="Screening not found")
        return row_to_dict(row)
    except IntegrityError as e:
        raise HTTPException(status_code=400, detail=str(e.orig))

@app.delete("/aml/screenings/{screening_id}", status_code=204)
def delete_screening(screening_id: uuid.UUID, conn: Connection = Depends(get_conn)):
    res = conn.execute(text("DELETE FROM aml.screening WHERE screeningid=:id"), {"id": str(screening_id)})
    if res.rowcount == 0:
        raise HTTPException(status_code=404, detail="Screening not found")
    return

# ----------------------------------------------------------------------------
# Health
# ----------------------------------------------------------------------------
@app.get("/health")
def health(conn: Connection = Depends(get_conn)):
    row = conn.execute(text("SELECT 1 AS ok")).fetchone()
    return {"ok": row[0] == 1}